<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2023-02-24 Fri 14:29 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>&lrm;</title>
<meta name="author" content="lei" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
</head>
<body>
<div id="content" class="content">
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgbbc769d">1. Creational Pattern</a>
<ul>
<li><a href="#orgb406c6b">1.1. Factory method</a></li>
<li><a href="#org506a4cf">1.2. Abstract factory</a></li>
<li><a href="#orgb41569d">1.3. Builder</a></li>
<li><a href="#orgde9d7a6">1.4. Prototype</a></li>
<li><a href="#org0c1073e">1.5. Singleton</a></li>
</ul>
</li>
<li><a href="#org38b5d34">2. Structural Pattern</a>
<ul>
<li><a href="#orgff7ebe8">2.1. Adapter</a></li>
<li><a href="#orgd774693">2.2. Bridge</a></li>
<li><a href="#org8f64a09">2.3. Composite</a></li>
<li><a href="#orgd3af736">2.4. Decorator</a></li>
<li><a href="#orgd0271f3">2.5. Facade</a></li>
<li><a href="#org9e124ca">2.6. Flyweight</a></li>
<li><a href="#org552b54b">2.7. Proxy</a></li>
</ul>
</li>
<li><a href="#orga47e54d">3. Behavioral Pattern</a>
<ul>
<li><a href="#org6748426">3.1. Chain of Responsibility</a></li>
<li><a href="#orga02fcf7">3.2. Command</a></li>
<li><a href="#org5e80e6f">3.3. Iterator</a></li>
<li><a href="#org5591661">3.4. Mediator</a></li>
<li><a href="#org44d6f68">3.5. Memento</a></li>
<li><a href="#orga02863f">3.6. Observer</a></li>
<li><a href="#orgeb1c081">3.7. State</a></li>
<li><a href="#org01a4902">3.8. Strategy</a></li>
<li><a href="#org96a9e44">3.9. Template method</a></li>
<li><a href="#org3992421">3.10. Visitor</a></li>
</ul>
</li>
</ul>
</div>
</div>


<div id="outline-container-orgbbc769d" class="outline-2">
<h2 id="orgbbc769d"><span class="section-number-2">1.</span> Creational Pattern</h2>
<div class="outline-text-2" id="text-1">
<p>
这个设计模式提供了多个对象创建机制，可以提高现存代码的灵活度和复用程度。
</p>
</div>

<div id="outline-container-orgb406c6b" class="outline-3">
<h3 id="orgb406c6b"><span class="section-number-3">1.1.</span> Factory method</h3>
<div class="outline-text-3" id="text-1-1">
<p>
又叫：虚拟构造函数、Virtual Constructor、Factory Method
</p>
</div>
<div id="outline-container-org0c297bb" class="outline-4">
<h4 id="org0c297bb"><span class="section-number-4">1.1.1.</span> Intent</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
工厂方法模式是一种创建型设计模式， 其在父类中提供一个创建对象的方法， 允许子类决
定实例化对象的类型。
</p>


<div id="orga6e6e52" class="figure">
<p><img src="file:///home/lei/github/lei0lei.github.io/resource/python/designpattern_ims/factory-method-1.png" alt="factory-method-1.png" />
</p>
</div>
</div>
</div>


<div id="outline-container-org2bbd56d" class="outline-4">
<h4 id="org2bbd56d"><span class="section-number-4">1.1.2.</span> Problem</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
这可是个好消息。 但是代码问题该如何处理呢？ 目前， 大部分代码都与`卡车`类相关。在
程序中添加`轮船`类需要修改全部代码。 更糟糕的是， 如果你以后需要在程序中支持另外
一种运输方式， 很可能需要再次对这些代码进行大幅修改。
</p>

<p>
最后， 你将不得不编写繁复的代码， 根据不同的运输对象类， 在应用中进行不同的处理。
</p>


<div id="orge682af1" class="figure">
<p><img src="file:///home/lei/github/lei0lei.github.io/resource/python/designpattern_ims/problem1-en.png" alt="problem1-en.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org9c525b5" class="outline-4">
<h4 id="org9c525b5"><span class="section-number-4">1.1.3.</span> Solution</h4>
<div class="outline-text-4" id="text-1-1-3">
<p>
工厂方法模式建议使用特殊的工厂方法代替对于对象构造函数的直接调用 （即使用
`new`运算符）。 不用担心， 对象仍将通过`new`运算符创建， 只是该运算符改在工厂方
法中调用罢了。 工厂方法返回的对象通常被称作 “产品”。
</p>


<div id="org4d9065e" class="figure">
<p><img src="file:///home/lei/github/lei0lei.github.io/resource/python/designpattern_ims/solution1.png" alt="solution1.png" />
</p>
</div>

<p>
乍看之下， 这种更改可能毫无意义： 我们只是改变了程序中调用构造函数的位置而已。
但是， 仔细想一下， 现在你可以在子类中重写工厂方法， 从而改变其创建产品的类型。
</p>

<p>
但有一点需要注意:仅当这些产品具有共同的基类或者接口时， 子类才能返回不同类型的产
品， 同时基类中的工厂方法还应将其返回类型声明为这一共有接口。
</p>

<p>
ATTR<sub>ORG</sub>: :width 1200
<img src="file:///home/lei/github/lei0lei.github.io/resource/python/designpattern_ims/solution2-en.png" alt="solution2-en.png" />
</p>

<p>
比如`Truck`和`Ship`类都应该实现`Transport`接口，声明一个`deliver`方法。每个子类的方法实现不同，卡车通过陆地运输，船通过海运。
在`RoadLogistics`类的工厂方法返回卡车对象，`SeaLogistics`类返回船对象。
ATTR<sub>ORG</sub>: :width 1200
<img src="file:///home/lei/github/lei0lei.github.io/resource/python/designpattern_ims/solution3-en.png" alt="solution3-en.png" />
</p>

<p>
举例来说，卡车`Truck`和 轮船`Ship`类都必须实现 运输`Transport`接口， 该接口声明了一
个名为 `deliver`交付的方法。 每个类都将以不同的方式实现该方法： 卡车走陆路交付货物，
轮船走海路交付货物。 ​ 陆路运输`Road­Logistics`类中的工厂方法返回卡车对象， 而 海路
运输`Sea­Logistics`类则返回轮船对象。
</p>

<p>
只要产品类实现一个共同的接口， 你就可以将其对象传递给客户代码， 而无需提供额外数据。
</p>

<p>
调用工厂方法的代码 （通常被称为客户端代码） 无需了解不同子类返回实际对象之间的差
别。 客户端将所有产品视为抽象的 运输 。 客户端知道所有运输对象都提供 交付方法，
但是并不关心其具体实现方式。
</p>
</div>
</div>

<div id="outline-container-org563e9d0" class="outline-4">
<h4 id="org563e9d0"><span class="section-number-4">1.1.4.</span> Structure</h4>
<div class="outline-text-4" id="text-1-1-4">
<p>
ATTR<sub>ORG</sub>: :width 1200
<img src="file:///home/lei/github/lei0lei.github.io/resource/python/designpattern_ims/structure.png" alt="structure.png" />
</p>

<ol class="org-ol">
<li>产品 （Product） 将会对接口进行声明。 对于所有由创建者及其子类构建的对象， 这
些接口都是通用的。</li>
<li>具体产品 （Concrete Products） 是产品接口的不同实现。</li>
<li><p>
创建者 （Creator） 类声明返回产品对象的工厂方法。 该方法的返回对象类型必须与
产品接口相匹配。
</p>

<p>
你可以将工厂方法声明为抽象方法， 强制要求每个子类以不同方式实现该方法。 或者，
你也可以在基础工厂方法中返回默认产品类型。
</p>

<p>
注意， 尽管它的名字是创建者， 但它最主要的职责并不是创建产品。 一般来说， 创
建者类包含一些与产品相关的核心业务逻辑。 工厂方法将这些逻辑处理从具体产品类中
分离出来。 打个比方， 大型软件开发公司拥有程序员培训部门。 但是， 这些公司的
主要工作还是编写代码， 而非生产程序员。
</p></li>

<li><p>
具体创建者 （Concrete Creators） 将会重写基础工厂方法， 使其返回不同类型的产
品。
</p>

<p>
注意， 并不一定每次调用工厂方法都会创建新的实例。 工厂方法也可以返回缓存、 对
象池或其他来源的已有对象。
</p></li>
</ol>
</div>
</div>

<div id="outline-container-org5c9a43e" class="outline-4">
<h4 id="org5c9a43e"><span class="section-number-4">1.1.5.</span> Pseudocode</h4>
<div class="outline-text-4" id="text-1-1-5">
<p>
以下示例演示了如何使用工厂方法开发跨平台 UI （用户界面） 组件， 并同时避免客户代
码与具体 UI 类之间的耦合。
</p>


<div id="orgc2bf936" class="figure">
<p><img src="file:///home/lei/github/lei0lei.github.io/resource/python/designpattern_ims/example.png" alt="example.png" />
</p>
</div>

<p>
基础对话框类使用不同的 UI 组件渲染窗口。 在不同的操作系统下， 这些组件外观或许略
有不同， 但其功能保持一致。 Windows 系统中的按钮在 Linux 系统中仍然是按钮。
</p>

<p>
如果使用工厂方法， 就不需要为每种操作系统重写对话框逻辑。 如果我们声明了一个在基
本对话框类中生成按钮的工厂方法， 那么我们就可以创建一个对话框子类， 并使其通过工
厂方法返回 Windows 样式按钮。 子类将继承对话框基础类的大部分代码， 同时在屏幕上
根据 Windows 样式渲染按钮。
</p>

<p>
如需该模式正常工作， 基础对话框类必须使用抽象按钮 （例如基类或接口）， 以便将其
扩展为具体按钮。 这样一来， 无论对话框中使用何种类型的按钮， 其代码都可以正常工
作。
</p>

<p>
你可以使用此方法开发其他 UI 组件。 不过， 每向对话框中添加一个新的工厂方法， 你
就离抽象工厂模式更近一步。 我们将在稍后谈到这个模式。
</p>

<div class="org-src-container">
<pre class="src src-java">
// 创建者类声明的工厂方法必须返回一个产品类的对象。创建者的子类通常会提供
// 该方法的实现。
class Dialog is
    // 创建者还可提供一些工厂方法的默认实现。
    abstract method createButton():Button

    // 请注意，创建者的主要职责并非是创建产品。其中通常会包含一些核心业务
    // 逻辑，这些逻辑依赖于由工厂方法返回的产品对象。子类可通过重写工厂方
    // 法并使其返回不同类型的产品来间接修改业务逻辑。
    method render() is
        // 调用工厂方法创建一个产品对象。
        Button okButton = createButton()
        // 现在使用产品。
        okButton.onClick(closeDialog)
        okButton.render()


// 具体创建者将重写工厂方法以改变其所返回的产品类型。
class WindowsDialog extends Dialog is
    method createButton():Button is
        return new WindowsButton()

class WebDialog extends Dialog is
    method createButton():Button is
        return new HTMLButton()


// 产品接口中将声明所有具体产品都必须实现的操作。
interface Button is
    method render()
    method onClick(f)

// 具体产品需提供产品接口的各种实现。
class WindowsButton implements Button is
    method render(a, b) is
        // 根据 Windows 样式渲染按钮。
    method onClick(f) is
        // 绑定本地操作系统点击事件。

class HTMLButton implements Button is
    method render(a, b) is
        // 返回一个按钮的 HTML 表述。
    method onClick(f) is
        // 绑定网络浏览器的点击事件。


class Application is
    field dialog: Dialog

    // 程序根据当前配置或环境设定选择创建者的类型。
    method initialize() is
        config = readApplicationConfigFile()

        if (config.OS == "Windows") then
            dialog = new WindowsDialog()
        else if (config.OS == "Web") then
            dialog = new WebDialog()
        else
            throw new Exception("错误！未知的操作系统。")

    // 当前客户端代码会与具体创建者的实例进行交互，但是必须通过其基本接口
    // 进行。只要客户端通过基本接口与创建者进行交互，你就可将任何创建者子
    // 类传递给客户端。
    method main() is
        this.initialize()
        dialog.render()

</pre>
</div>
</div>
</div>

<div id="outline-container-org362c8f7" class="outline-4">
<h4 id="org362c8f7"><span class="section-number-4">1.1.6.</span> Applicability</h4>
<div class="outline-text-4" id="text-1-1-6">
<ul class="org-ul">
<li><p>
当你在编写代码的过程中， 如果无法预知对象确切类别及其依赖关系时， 可使用工厂方
法。
</p>

<p>
工厂方法将创建产品的代码与实际使用产品的代码分离， 从而能在不影响其他代码的情
况下扩展产品创建部分代码。
</p>

<p>
例如， 如果需要向应用中添加一种新产品， 你只需要开发新的创建者子类， 然后重写
其工厂方法即可。
</p></li>

<li><p>
如果你希望用户能扩展你软件库或框架的内部组件， 可使用工厂方法。
</p>

<p>
继承可能是扩展软件库或框架默认行为的最简单方法。 但是当你使用子类替代标准组件
时， 框架如何辨识出该子类？
</p>

<p>
解决方案是将各框架中构造组件的代码集中到单个工厂方法中， 并在继承该组件之外允
许任何人对该方法进行重写。
</p>

<p>
让我们看看具体是如何实现的。 假设你使用开源 UI 框架编写自己的应用。 你希望在应
用中使用圆形按钮， 但是原框架仅支持矩形按钮。 你可以使用 圆形按钮Round­Button
子类来继承标准的 按钮Button类。 但是， 你需要告诉 UI框架UIFramework类使用新的
子类按钮代替默认按钮。
</p>

<p>
为了实现这个功能， 你可以根据基础框架类开发子类 圆形按钮
UIUIWith­Round­Buttons ， 并且重写其 create­Button创建按钮方法。 基类中的该方
法返回 按钮对象， 而你开发的子类返回 圆形按钮对象。 现在， 你就可以使用 圆形按
钮 UI类代替 UI框架类。 就是这么简单！
</p></li>

<li><p>
如果你希望复用现有对象来节省系统资源， 而不是每次都重新创建对象， 可使用工厂方法。
</p>

<p>
在处理大型资源密集型对象 （比如数据库连接、 文件系统和网络资源） 时， 你会经常
碰到这种资源需求。
</p>

<p>
让我们思考复用现有对象的方法：
</p>

<ol class="org-ol">
<li>首先， 你需要创建存储空间来存放所有已经创建的对象。</li>
<li>当他人请求一个对象时， 程序将在对象池中搜索可用对象。</li>
<li>… 然后将其返回给客户端代码。</li>
<li>如果没有可用对象， 程序则创建一个新对象 （并将其添加到对象池中）。</li>
</ol>

<p>
这些代码可不少！ 而且它们必须位于同一处， 这样才能确保重复代码不会污染程序。
</p>

<p>
可能最显而易见， 也是最方便的方式， 就是将这些代码放置在我们试图重用的对象类的
构造函数中。 但是从定义上来讲， 构造函数始终返回的是新对象， 其无法返回现有实
例。
</p>

<p>
因此， 你需要有一个既能够创建新对象， 又可以重用现有对象的普通方法。 这听上去
和工厂方法非常相像。
</p></li>
</ul>
</div>
</div>


<div id="outline-container-org7d3cf23" class="outline-4">
<h4 id="org7d3cf23"><span class="section-number-4">1.1.7.</span> How to Implement</h4>
<div class="outline-text-4" id="text-1-1-7">
<ol class="org-ol">
<li>让所有产品都遵循同一接口。 该接口必须声明对所有产品都有意义的方法。</li>

<li>在创建类中添加一个空的工厂方法。 该方法的返回类型必须遵循通用的产品接口。</li>

<li><p>
在创建者代码中找到对于产品构造函数的所有引用。 将它们依次替换为对于工厂方法的
调用， 同时将创建产品的代码移入工厂方法。
</p>

<p>
你可能需要在工厂方法中添加临时参数来控制返回的产品类型。
</p>

<p>
工厂方法的代码看上去可能非常糟糕。 其中可能会有复杂的 switch分支运算符， 用于
选择各种需要实例化的产品类。 但是不要担心， 我们很快就会修复这个问题。
</p></li>

<li>现在， 为工厂方法中的每种产品编写一个创建者子类， 然后在子类中重写工厂方法，
并将基本方法中的相关创建代码移动到工厂方法中。</li>

<li><p>
如果应用中的产品类型太多， 那么为每个产品创建子类并无太大必要， 这时你也可以
在子类中复用基类中的控制参数。
</p>

<p>
例如， 设想你有以下一些层次结构的类。 基类 `邮件`及其子类 `航空邮件`和 `陆路邮
 件` ； ​`运输`及其子类`飞机`,`卡车`和`火车`。`航空邮件`仅使用 `飞机对象`， 而
 `陆路邮件`则会同时使用 `卡车`和 `火车`对象。 你可以编写一个新的子类 （例如
 `火车邮件`)来处理这两种情况， 但是还有其他可选的方案。客户端代码可以给 `陆
 路邮件`类传递一个参数， 用于控制其希望获得的产品。
</p></li>

<li>如果代码经过上述移动后， 基础工厂方法中已经没有任何代码， 你可以将其转变为抽
象类。 如果基础工厂方法中还有其他语句， 你可以将其设置为该方法的默认行为。</li>
</ol>
</div>
</div>




<div id="outline-container-org78ac6d4" class="outline-4">
<h4 id="org78ac6d4"><span class="section-number-4">1.1.8.</span> Pros and Cons</h4>
<div class="outline-text-4" id="text-1-1-8">
<ul class="org-ul">
<li>pros
<ul class="org-ul">
<li>你可以避免创建者和具体产品之间的紧密耦合。</li>
<li>单一职责原则。 你可以将产品创建代码放在程序的单一位置， 从而使得代码更容易维护。</li>
<li>开闭原则。 无需更改现有客户端代码， 你就可以在程序中引入新的产品类型。</li>
</ul></li>

<li>cons
<ul class="org-ul">
<li>应用工厂方法模式需要引入许多新的子类， 代码可能会因此变得更复杂。 最好的情况
是将该模式引入创建者类的现有层次结构中。</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgcafc80a" class="outline-4">
<h4 id="orgcafc80a"><span class="section-number-4">1.1.9.</span> Relations with Other Patterns</h4>
<div class="outline-text-4" id="text-1-1-9">
<ul class="org-ul">
<li>在许多设计工作的初期都会使用工厂方法模式 （较为简单， 而且可以更方便地通过子类
进行定制）， 随后演化为使用抽象工厂模式、 原型模式或生成器模式 （更灵活但更加
复杂）。</li>

<li>抽象工厂模式通常基于一组工厂方法， 但你也可以使用原型模式来生成这些类的方法。</li>

<li>你可以同时使用工厂方法和迭代器模式来让子类集合返回不同类型的迭代器， 并使得迭
代器与集合相匹配。</li>

<li>原型并不基于继承， 因此没有继承的缺点。 另一方面， 原型需要对被复制对象进行复
杂的初始化。 工厂方法基于继承， 但是它不需要初始化步骤。</li>

<li>工厂方法是模板方法模式的一种特殊形式。 同时， 工厂方法可以作为一个大型模板方法
中的一个步骤。</li>
</ul>
</div>
</div>

<div id="outline-container-orgbe310bf" class="outline-4">
<h4 id="orgbe310bf"><span class="section-number-4">1.1.10.</span> python 示例</h4>
<div class="outline-text-4" id="text-1-1-10">
<p>
工厂方法是一种创建型设计模式， 解决了在不指定具体类的情况下创建产品对象的问题。
工厂方法定义了一个方法， 且必须使用该方法代替通过直接调用构造函数来创建对象
（ new操作符） 的方式。 子类可重写该方法来更改将被创建的对象所属类。
</p>

<p>
python示例：
</p>

<div class="org-src-container">
<pre class="src src-python">from __future__ import annotations
from abc import ABC, abstractmethod


class Creator(ABC):
    """
    The Creator class declares the factory method that is supposed to return an
    object of a Product class. The Creator's subclasses usually provide the
    implementation of this method.
    """

    @abstractmethod
    def factory_method(self):
        """
        Note that the Creator may also provide some default implementation of
        the factory method.
        """
        pass

    def some_operation(self) -&gt; str:
        """
        Also note that, despite its name, the Creator's primary responsibility
        is not creating products. Usually, it contains some core business logic
        that relies on Product objects, returned by the factory method.
        Subclasses can indirectly change that business logic by overriding the
        factory method and returning a different type of product from it.
        """

        # Call the factory method to create a Product object.
        product = self.factory_method()

        # Now, use the product.
        result = f"Creator: The same creator's code has just worked with {product.operation()}"

        return result


"""
Concrete Creators override the factory method in order to change the resulting
product's type.
"""


class ConcreteCreator1(Creator):
    """
    Note that the signature of the method still uses the abstract product type,
    even though the concrete product is actually returned from the method. This
    way the Creator can stay independent of concrete product classes.
    """

    def factory_method(self) -&gt; Product:
        return ConcreteProduct1()


class ConcreteCreator2(Creator):
    def factory_method(self) -&gt; Product:
        return ConcreteProduct2()


class Product(ABC):
    """
    The Product interface declares the operations that all concrete products
    must implement.
    """

    @abstractmethod
    def operation(self) -&gt; str:
        pass


"""
Concrete Products provide various implementations of the Product interface.
"""


class ConcreteProduct1(Product):
    def operation(self) -&gt; str:
        return "{Result of the ConcreteProduct1}"


class ConcreteProduct2(Product):
    def operation(self) -&gt; str:
        return "{Result of the ConcreteProduct2}"


def client_code(creator: Creator) -&gt; None:
    """
    The client code works with an instance of a concrete creator, albeit through
    its base interface. As long as the client keeps working with the creator via
    the base interface, you can pass it any creator's subclass.
    """

    print(f"Client: I'm not aware of the creator's class, but it still works.\n"
          f"{creator.some_operation()}", end="")

if __name__ == "__main__":
    print("App: Launched with the ConcreteCreator1.")
    client_code(ConcreteCreator1())
    print("\n")

    print("App: Launched with the ConcreteCreator2.")
    client_code(ConcreteCreator2())
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org506a4cf" class="outline-3">
<h3 id="org506a4cf"><span class="section-number-3">1.2.</span> Abstract factory</h3>
</div>


<div id="outline-container-orgb41569d" class="outline-3">
<h3 id="orgb41569d"><span class="section-number-3">1.3.</span> Builder</h3>
</div>


<div id="outline-container-orgde9d7a6" class="outline-3">
<h3 id="orgde9d7a6"><span class="section-number-3">1.4.</span> Prototype</h3>
</div>


<div id="outline-container-org0c1073e" class="outline-3">
<h3 id="org0c1073e"><span class="section-number-3">1.5.</span> Singleton</h3>
</div>
</div>



<div id="outline-container-org38b5d34" class="outline-2">
<h2 id="org38b5d34"><span class="section-number-2">2.</span> Structural Pattern</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-orgff7ebe8" class="outline-3">
<h3 id="orgff7ebe8"><span class="section-number-3">2.1.</span> Adapter</h3>
</div>



<div id="outline-container-orgd774693" class="outline-3">
<h3 id="orgd774693"><span class="section-number-3">2.2.</span> Bridge</h3>
</div>



<div id="outline-container-org8f64a09" class="outline-3">
<h3 id="org8f64a09"><span class="section-number-3">2.3.</span> Composite</h3>
</div>


<div id="outline-container-orgd3af736" class="outline-3">
<h3 id="orgd3af736"><span class="section-number-3">2.4.</span> Decorator</h3>
</div>


<div id="outline-container-orgd0271f3" class="outline-3">
<h3 id="orgd0271f3"><span class="section-number-3">2.5.</span> Facade</h3>
</div>

<div id="outline-container-org9e124ca" class="outline-3">
<h3 id="org9e124ca"><span class="section-number-3">2.6.</span> Flyweight</h3>
</div>


<div id="outline-container-org552b54b" class="outline-3">
<h3 id="org552b54b"><span class="section-number-3">2.7.</span> Proxy</h3>
</div>
</div>







<div id="outline-container-orga47e54d" class="outline-2">
<h2 id="orga47e54d"><span class="section-number-2">3.</span> Behavioral Pattern</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-org6748426" class="outline-3">
<h3 id="org6748426"><span class="section-number-3">3.1.</span> Chain of Responsibility</h3>
</div>




<div id="outline-container-orga02fcf7" class="outline-3">
<h3 id="orga02fcf7"><span class="section-number-3">3.2.</span> Command</h3>
</div>


<div id="outline-container-org5e80e6f" class="outline-3">
<h3 id="org5e80e6f"><span class="section-number-3">3.3.</span> Iterator</h3>
</div>



<div id="outline-container-org5591661" class="outline-3">
<h3 id="org5591661"><span class="section-number-3">3.4.</span> Mediator</h3>
</div>




<div id="outline-container-org44d6f68" class="outline-3">
<h3 id="org44d6f68"><span class="section-number-3">3.5.</span> Memento</h3>
</div>



<div id="outline-container-orga02863f" class="outline-3">
<h3 id="orga02863f"><span class="section-number-3">3.6.</span> Observer</h3>
</div>


<div id="outline-container-orgeb1c081" class="outline-3">
<h3 id="orgeb1c081"><span class="section-number-3">3.7.</span> State</h3>
</div>


<div id="outline-container-org01a4902" class="outline-3">
<h3 id="org01a4902"><span class="section-number-3">3.8.</span> Strategy</h3>
</div>


<div id="outline-container-org96a9e44" class="outline-3">
<h3 id="org96a9e44"><span class="section-number-3">3.9.</span> Template method</h3>
</div>



<div id="outline-container-org3992421" class="outline-3">
<h3 id="org3992421"><span class="section-number-3">3.10.</span> Visitor</h3>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: lei</p>
<p class="date">Created: 2023-02-24 Fri 14:29</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
